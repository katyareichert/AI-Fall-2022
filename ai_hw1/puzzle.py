# -*- coding: utf-8 -*-
"""puzzle.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P86bEDU_V88AIfV4EOsS3NVNx3s1jXUi
"""

from __future__ import division
from __future__ import print_function

import sys
import math
import time
import queue as Q
import resource

#### SKELETON CODE ####
## The Class that Represents the Puzzle
class PuzzleState(object):
    """
        The PuzzleState stores a board configuration and implements
        movement instructions to generate valid children.
    """
    def __init__(self, config, n, parent=None, action="Initial", cost=0):
        """
        :param config->List : Represents the n*n board, for e.g. [0,1,2,3,4,5,6,7,8] represents the goal state.
        :param n->int : Size of the board
        :param parent->PuzzleState
        :param action->string
        :param cost->int
        """
        if n*n != len(config) or n < 2:
            raise Exception("The length of config is not correct!")
        if set(config) != set(range(n*n)):
            raise Exception("Config contains invalid/duplicate entries : ", config)

        self.n        = n
        self.cost     = cost
        self.parent   = parent
        self.action   = action
        self.config   = config
        self.children = []

        # Get the index and (row, col) of empty block
        self.blank_index = self.config.index(0)

    def __lt__(self, other):
        return self.cost < other.cost

    def display(self):
        """ Display this Puzzle state as a n*n board """
        for i in range(self.n):
            print(self.config[3*i : 3*(i+1)])

    def move_up(self):
        """ 
        Moves the blank tile one row up.
        :return a PuzzleState with the new configuration
        """

        if self.blank_index < self.n:
          return None

        new_value_index = self.blank_index - self.n

        child = PuzzleState(list(self.config), self.n, parent=self, cost=1)                # create new state
        child.config[child.blank_index] = child.config[new_value_index]         # move the non-blank tile value into blank spot
        child.config[new_value_index] = 0                                       # put 0 (blank) where the non-blank tile came from
        child.blank_index = child.config.index(0)                               # update the child's blank_index property
        child.action = "Up"

        return child
      
    def move_down(self):
        """
        Moves the blank tile one row down.
        :return a PuzzleState with the new configuration
        """

        if self.blank_index >= (self.n - 1)*self.n:
          return None

        new_value_index = self.blank_index + self.n

        
        child = PuzzleState(list(self.config), self.n, parent=self, cost=1)                # create new state
        child.config[child.blank_index] = child.config[new_value_index]         # move the non-blank tile value into blank spot
        child.config[new_value_index] = 0                                       # put 0 (blank) where the non-blank tile came from
        child.blank_index = child.config.index(0)                               # update the child's blank_index property
        child.action = "Down"

        return child
      
    def move_left(self):
        """
        Moves the blank tile one column to the left.
        :return a PuzzleState with the new configuration
        """

        if (self.blank_index + self.n) % self.n == 0:
          return None

        new_value_index = self.blank_index - 1

        
        child = PuzzleState(list(self.config), self.n, parent=self, cost=1)                # create new state
        child.config[child.blank_index] = child.config[new_value_index]         # move the non-blank tile value into blank spot
        child.config[new_value_index] = 0                                       # put 0 (blank) where the non-blank tile came from
        child.blank_index = child.config.index(0)                               # update the child's blank_index property
        child.action = "Left"

        return child

    def move_right(self):
        """
        Moves the blank tile one column to the right.
        :return a PuzzleState with the new configuration
        """

        if (self.blank_index + 1) % self.n == 0:
          return None

        new_value_index = self.blank_index + 1

        
        child = PuzzleState(list(self.config), self.n, parent=self, cost=1)                # create new state
        child.config[child.blank_index] = child.config[new_value_index]         # move the non-blank tile value into blank spot
        child.config[new_value_index] = 0                                       # put 0 (blank) where the non-blank tile came from
        child.blank_index = child.config.index(0)                               # update the child's blank_index property
        child.action = "Right"

        return child
      
    def expand(self):
        """ Generate the child nodes of this node """
        
        # Node has already been expanded
        if len(self.children) != 0:
            return self.children
        
        # Add child nodes in order of UDLR
        children = [
            self.move_up(),
            self.move_down(),
            self.move_left(),
            self.move_right()]

        # Compose self.children of all non-None children states
        self.children = [state for state in children if state is not None]
        return self.children

dfs_start_ram = 0
start_time = 0

# Function that Writes to output.txt

""" Students need to change the method to have the corresponding parameters """

def writeOutput(type, initial_state, goal_state, nodes_expanded):
    ### Student Code Goes here
    # print("yell heah")

    state_trace = goal_state
    path_to_goal = Q.deque([])
    cost_of_path = 0
    search_depth = 0
    max_search_depth = 0


    while state_trace.action != "Initial":
      path_to_goal.appendleft(state_trace.action)
      cost_of_path +=1 
      search_depth += 1

      state_trace = state_trace.parent
    
    if type == "bfs":
      max_search_depth = search_depth+1
    else:
      max_search_depth = search_depth

    # print
    """print("path_to_goal: " + str(list(path_to_goal)))
    print("cost_of_path: " + str(cost_of_path))
    print("nodes_expanded: " + str(nodes_expanded))
    print("search_depth: " + str(search_depth))
    print("max_search_depth: " + str(max_search_depth))"""

    # write to file
    f = open("output.txt", "w")
    f.write("path_to_goal: " + str(list(path_to_goal)))
    f.write("\ncost_of_path: " + str(cost_of_path))
    f.write("\nnodes_expanded: " + str(nodes_expanded))
    f.write("\nsearch_depth: " + str(search_depth))
    f.write("\nmax_search_depth: " + str(max_search_depth))

    end_time = time.time()
    f.write("\nProgram completed in %.3f second(s)"%(end_time-start_time))

    dfs_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - dfs_start_ram)/(2**20)
    f.write("\nmax_ram_usage: "+str(round(dfs_ram, 8)))
    
    f.close()

def bfs_search(initial_state):
    """BFS search"""
    ### STUDENT CODE GOES HERE ###

    nodes_expanded = 0

    frontier = Q.deque([initial_state])
    front_members = {str(initial_state.config): 0}                              # dictionary of frontier for O(1) member checking
    explored = {}                                                               # dictionary of explored for O(1) member checking

    while len(frontier) > 0:
      state = frontier.pop()
      front_members.pop(str(state.config))

      explored[str(state.config)] = 1

      if test_goal(state):
        writeOutput("bfs", initial_state, state, nodes_expanded)
        return

      if len(state.children) == 0:
        nodes_expanded +=1
      state.children = state.expand()

      for neighbor in state.children:
        if str(neighbor.config) not in explored and str(neighbor.config) not in front_members:
          frontier.appendleft(neighbor)
          front_members[str(neighbor.config)] = 0

    return

def dfs_search(initial_state):
    """DFS search"""
    ### STUDENT CODE GOES HERE ###

    nodes_expanded = 0

    frontier = Q.deque([initial_state])
    front_members = {str(initial_state.config): 0}                              # dictionary of frontier for O(1) member checking
    explored = {}                                                               # dictionary of explored for O(1) member checking

    while len(frontier) > 0:
      state = frontier.pop()
      front_members.pop(str(state.config))

      explored[str(state.config)] = 1

      if test_goal(state):
        writeOutput("dfs", initial_state, state, nodes_expanded)
        return

      if len(state.children) == 0:
        nodes_expanded +=1
      state.children = state.expand()

      for neighbor in reversed(state.children):
        if str(neighbor.config) not in explored and str(neighbor.config) not in front_members:
          frontier.append(neighbor)
          front_members[str(neighbor.config)] = 0

    return

def A_star_search(initial_state):
    """A * search"""
    ### STUDENT CODE GOES HERE ###

    nodes_expanded = 0

    frontier = Q.PriorityQueue()
    frontier.put((0, initial_state))
    initial_state.cost = calculate_total_cost(initial_state)
    explored = {}

    while not frontier.empty():

      state = frontier.get()[1]

      state.cost = calculate_total_cost(state)
      explored[str(state.config)] = state.cost

      if test_goal(state):
        writeOutput("ast", initial_state, state, nodes_expanded)
        return

      if len(state.children) == 0:
        nodes_expanded +=1
      state.children = state.expand()

      for neighbor in state.children:
        if str(neighbor.config) not in explored:
          neighbor.cost = calculate_total_cost(neighbor)
          frontier.put((neighbor.cost, neighbor))

    return

def calculate_total_cost(state):
    """calculate the total estimated cost of a state"""
    ### STUDENT CODE GOES HERE ###

    state_trace = state
    cost_of_path = 0

    while state_trace.action != "Initial":
      cost_of_path += 1
      state_trace = state_trace.parent

    for i in range(state.n ** 2):
      cost_of_path += calculate_manhattan_dist(i, state.config[i], state.n)

    return cost_of_path

def calculate_manhattan_dist(idx, value, n):
    """calculate the manhattan distance of a tile"""
    ### STUDENT CODE GOES HERE ###

    coordinate = [idx%n , int(idx/3)]

    goal_coord = []
    for i in range(0,n):
      for j in range(0,n):
        goal_coord.append([j,i])

    return abs(coordinate[0] - goal_coord[value][0]) + abs(coordinate[1] - goal_coord[value][1])


def test_goal(puzzle_state):
    """test the state is the goal state or not"""
    ### STUDENT CODE GOES HERE ###
    goal_state = list(range(0,puzzle_state.n**2))

    if puzzle_state.config == goal_state:
      return True

    return False

# Main Function that reads in Input and Runs corresponding Algorithm
def main():

    search_mode = sys.argv[1].lower()
    begin_state = sys.argv[2].split(",")

    #search_mode = "ast"
    #begin_state = 8,6,4,2,1,3,5,7,0

    begin_state = list(map(int, begin_state))
    board_size  = int(math.sqrt(len(begin_state)))
    hard_state  = PuzzleState(begin_state, board_size)
    start_time  = time.time()
    
    dfs_start_ram = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss

    if   search_mode == "bfs": bfs_search(hard_state)
    elif search_mode == "dfs": dfs_search(hard_state)
    elif search_mode == "ast": A_star_search(hard_state)
    else: 
        print("Enter valid command arguments !")
        
    end_time = time.time()
    print("Program completed in %.3f second(s)"%(end_time-start_time))

if __name__ == '__main__':
    main()